# リレーション仕様書

## プロジェクト: ユーザー管理システム
**作成日**: 2025-11-15
**バージョン**: 1.0

---

## 目次
1. [リレーション概要](#リレーション概要)
2. [1対1リレーション](#1対1リレーション)
3. [1対多リレーション](#1対多リレーション)
4. [多対多リレーション（将来実装）](#多対多リレーション将来実装)
5. [リレーション制約](#リレーション制約)

---

## リレーション概要

### リレーションシップ一覧

| No | 親テーブル | 子テーブル | リレーション種別 | カーディナリティ | 外部キー | 備考 |
|----|-----------|-----------|---------------|---------------|---------|------|
| 1 | users | user_profiles | 1対1 | 1:0..1 | user_profiles.user_id | ユーザーとプロフィール |
| 2 | users | user_sessions | 1対多 | 1:0..* | user_sessions.user_id | ユーザーとセッション |
| 3 | users | user_role_assignments | 1対多 | 1:0..* | user_role_assignments.user_id | ユーザーとロール割り当て（将来） |
| 4 | roles | user_role_assignments | 1対多 | 1:0..* | user_role_assignments.role_id | ロールとユーザー割り当て（将来） |

---

## 1対1リレーション

### 1. users ←→ user_profiles

#### リレーション詳細
```
users (1) ←────→ (0..1) user_profiles
  [id]              [user_id]
```

#### 説明
- **親テーブル**: users
- **子テーブル**: user_profiles
- **カーディナリティ**: 1対0..1
  - 1人のユーザーは0個または1個のプロフィールを持つ
  - 1つのプロフィールは必ず1人のユーザーに属する
- **外部キー**: user_profiles.user_id → users.id
- **一意性制約**: user_profiles.user_idにUNIQUE制約

#### DDL定義
```sql
-- 外部キー制約
ALTER TABLE user_profiles
ADD CONSTRAINT fk_user_profiles_user_id
    FOREIGN KEY (user_id)
    REFERENCES users(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE;

-- 一意性制約（1対1を保証）
ALTER TABLE user_profiles
ADD CONSTRAINT uk_user_profiles_user_id
    UNIQUE (user_id);
```

#### ビジネスルール
1. **作成**: ユーザー登録時にプロフィールも同時作成
2. **更新**: ユーザーはいつでもプロフィールを更新可能
3. **削除**: ユーザー削除時にプロフィールも削除（CASCADE）
4. **参照整合性**: プロフィールは必ず有効なユーザーに紐づく

#### サンプルデータ
```sql
-- users
INSERT INTO users (id, email, first_name, last_name, ...)
VALUES ('usr_001', 'taro@example.com', '太郎', '山田', ...);

-- user_profiles（1対1で対応）
INSERT INTO user_profiles (id, user_id, bio, phone_number, ...)
VALUES ('prf_001', 'usr_001', '自己紹介文...', '090-1234-5678', ...);
```

#### JOIN例
```sql
-- ユーザーとプロフィールの取得
SELECT
    u.id,
    u.email,
    u.first_name,
    u.last_name,
    p.bio,
    p.phone_number,
    p.profile_image_url
FROM users u
LEFT JOIN user_profiles p ON u.id = p.user_id
WHERE u.id = 'usr_001';
```

---

## 1対多リレーション

### 2. users ←→ user_sessions

#### リレーション詳細
```
users (1) ←────→ (0..*) user_sessions
  [id]               [user_id]
```

#### 説明
- **親テーブル**: users
- **子テーブル**: user_sessions
- **カーディナリティ**: 1対0..*
  - 1人のユーザーは0個以上のセッションを持つ
  - 1つのセッションは必ず1人のユーザーに属する
- **外部キー**: user_sessions.user_id → users.id
- **多重度**: 1ユーザーあたり最大5セッション（アプリ側で制御）

#### DDL定義
```sql
-- 外部キー制約
ALTER TABLE user_sessions
ADD CONSTRAINT fk_user_sessions_user_id
    FOREIGN KEY (user_id)
    REFERENCES users(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE;

-- インデックス（検索性能向上）
CREATE INDEX idx_user_sessions_user_id ON user_sessions(user_id);
```

#### ビジネスルール
1. **作成**: ログイン時にセッションを作成
2. **更新**: アクセスごとにlast_accessed_atを更新
3. **削除**:
   - ログアウト時にセッションを無効化（revoked_at設定）
   - 期限切れセッションは定期的に物理削除
   - ユーザー削除時にすべてのセッションも削除（CASCADE）
4. **制限**: 同時セッション数は最大5つまで
5. **セキュリティ**: リフレッシュトークンはハッシュ化して保存

#### サンプルデータ
```sql
-- users
INSERT INTO users (id, email, first_name, last_name, ...)
VALUES ('usr_001', 'taro@example.com', '太郎', '山田', ...);

-- user_sessions（1ユーザーに複数セッション）
INSERT INTO user_sessions (id, user_id, refresh_token, device_type, ...)
VALUES
    ('ses_001', 'usr_001', 'token1...', 'desktop', ...),
    ('ses_002', 'usr_001', 'token2...', 'mobile', ...),
    ('ses_003', 'usr_001', 'token3...', 'tablet', ...);
```

#### JOIN例
```sql
-- ユーザーのアクティブなセッション一覧
SELECT
    u.id AS user_id,
    u.email,
    s.id AS session_id,
    s.device_type,
    s.browser,
    s.last_accessed_at
FROM users u
INNER JOIN user_sessions s ON u.id = s.user_id
WHERE u.id = 'usr_001'
    AND s.is_active = TRUE
    AND s.expires_at > CURRENT_TIMESTAMP
ORDER BY s.last_accessed_at DESC;
```

#### 集計例
```sql
-- ユーザーごとのアクティブセッション数
SELECT
    u.id,
    u.email,
    COUNT(s.id) AS active_session_count
FROM users u
LEFT JOIN user_sessions s ON u.id = s.user_id
    AND s.is_active = TRUE
    AND s.expires_at > CURRENT_TIMESTAMP
GROUP BY u.id, u.email
HAVING COUNT(s.id) >= 5;  -- 上限到達ユーザー抽出
```

---

## 多対多リレーション（将来実装）

### 3. users ←→ roles（多対多）

#### リレーション詳細
```
users (1) ←────→ (0..*) user_role_assignments (0..*) ←────→ (1) roles
  [id]                    [user_id] [role_id]                  [id]
```

#### 説明
- **エンティティ**: users ←→ user_role_assignments ←→ roles
- **カーディナリティ**: 多対多
  - 1人のユーザーは複数のロールを持てる
  - 1つのロールは複数のユーザーに割り当てられる
- **中間テーブル**: user_role_assignments
- **外部キー**:
  - user_role_assignments.user_id → users.id
  - user_role_assignments.role_id → roles.id

#### テーブル定義

##### rolesテーブル
```sql
CREATE TABLE roles (
    id VARCHAR(50) NOT NULL,
    name VARCHAR(50) NOT NULL,
    description VARCHAR(255),
    permissions TEXT,  -- JSON形式で権限を保存
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT pk_roles PRIMARY KEY (id),
    CONSTRAINT uk_roles_name UNIQUE (name)
);
```

##### user_role_assignmentsテーブル（中間テーブル）
```sql
CREATE TABLE user_role_assignments (
    id VARCHAR(50) NOT NULL,
    user_id VARCHAR(50) NOT NULL,
    role_id VARCHAR(50) NOT NULL,
    assigned_by VARCHAR(50),  -- 割り当てた管理者ID
    assigned_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP,  -- ロール有効期限（NULLなら無期限）
    CONSTRAINT pk_user_role_assignments PRIMARY KEY (id),
    CONSTRAINT fk_ura_user_id FOREIGN KEY (user_id)
        REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_ura_role_id FOREIGN KEY (role_id)
        REFERENCES roles(id) ON DELETE CASCADE,
    CONSTRAINT uk_ura_user_role UNIQUE (user_id, role_id)  -- 重複防止
);
```

#### ビジネスルール
1. **作成**: 管理者がユーザーにロールを割り当て
2. **更新**: ロールの有効期限を変更可能
3. **削除**:
   - ロール削除時に該当の割り当ても削除（CASCADE）
   - ユーザー削除時に該当の割り当ても削除（CASCADE）
4. **重複防止**: 同じユーザーに同じロールを複数回割り当て不可
5. **有効期限**: expires_atで一時的なロール付与が可能

#### サンプルデータ
```sql
-- roles
INSERT INTO roles (id, name, description, permissions)
VALUES
    ('rol_001', 'admin', '管理者', '{"all": true}'),
    ('rol_002', 'moderator', 'モデレーター', '{"users.read": true, "users.update": true}'),
    ('rol_003', 'premium_user', 'プレミアムユーザー', '{"premium_features": true}');

-- users
INSERT INTO users (id, email, first_name, last_name, ...)
VALUES ('usr_001', 'taro@example.com', '太郎', '山田', ...);

-- user_role_assignments（多対多の中間テーブル）
INSERT INTO user_role_assignments (id, user_id, role_id, assigned_by)
VALUES
    ('ura_001', 'usr_001', 'rol_001', 'usr_admin'),  -- 太郎は管理者
    ('ura_002', 'usr_001', 'rol_003', 'usr_admin');  -- 太郎はプレミアムユーザーでもある
```

#### JOIN例
```sql
-- ユーザーに割り当てられたロール一覧
SELECT
    u.id AS user_id,
    u.email,
    r.name AS role_name,
    r.description AS role_description,
    ura.assigned_at,
    ura.expires_at
FROM users u
INNER JOIN user_role_assignments ura ON u.id = ura.user_id
INNER JOIN roles r ON ura.role_id = r.id
WHERE u.id = 'usr_001'
    AND (ura.expires_at IS NULL OR ura.expires_at > CURRENT_TIMESTAMP);
```

#### 逆引き例
```sql
-- 特定のロールを持つユーザー一覧
SELECT
    r.name AS role_name,
    u.id AS user_id,
    u.email,
    u.first_name,
    u.last_name
FROM roles r
INNER JOIN user_role_assignments ura ON r.id = ura.role_id
INNER JOIN users u ON ura.user_id = u.id
WHERE r.name = 'admin'
    AND (ura.expires_at IS NULL OR ura.expires_at > CURRENT_TIMESTAMP);
```

---

### 4. users ←→ groups（多対多）

#### リレーション詳細
```
users (1) ←────→ (0..*) user_group_memberships (0..*) ←────→ (1) groups
  [id]                    [user_id] [group_id]                  [id]
```

#### 説明
- **エンティティ**: users ←→ user_group_memberships ←→ groups
- **カーディナリティ**: 多対多
  - 1人のユーザーは複数のグループに所属できる
  - 1つのグループには複数のユーザーが所属できる
- **中間テーブル**: user_group_memberships
- **追加情報**: グループ内での役割（owner/admin/member）も管理

#### テーブル定義

##### groupsテーブル
```sql
CREATE TABLE groups (
    id VARCHAR(50) NOT NULL,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    is_private BOOLEAN NOT NULL DEFAULT FALSE,
    created_by VARCHAR(50) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT pk_groups PRIMARY KEY (id),
    CONSTRAINT fk_groups_created_by FOREIGN KEY (created_by)
        REFERENCES users(id)
);
```

##### user_group_membershipsテーブル（中間テーブル）
```sql
CREATE TABLE user_group_memberships (
    id VARCHAR(50) NOT NULL,
    user_id VARCHAR(50) NOT NULL,
    group_id VARCHAR(50) NOT NULL,
    role VARCHAR(20) NOT NULL DEFAULT 'member',  -- owner/admin/member
    joined_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT pk_user_group_memberships PRIMARY KEY (id),
    CONSTRAINT fk_ugm_user_id FOREIGN KEY (user_id)
        REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_ugm_group_id FOREIGN KEY (group_id)
        REFERENCES groups(id) ON DELETE CASCADE,
    CONSTRAINT uk_ugm_user_group UNIQUE (user_id, group_id),
    CONSTRAINT chk_ugm_role CHECK (role IN ('owner', 'admin', 'member'))
);
```

#### ビジネスルール
1. **作成**: グループ作成者は自動的にownerになる
2. **招待**: owner/adminがメンバーを招待可能
3. **権限**:
   - owner: すべての権限（削除、メンバー管理、設定変更）
   - admin: メンバー管理、投稿管理
   - member: 閲覧、投稿のみ
4. **退会**: 自分で退会可能（ownerは他のownerがいる場合のみ）
5. **削除**: グループ削除時にすべてのメンバーシップも削除（CASCADE）

#### サンプルデータ
```sql
-- groups
INSERT INTO groups (id, name, description, created_by)
VALUES
    ('grp_001', 'エンジニアグループ', '技術情報共有', 'usr_001'),
    ('grp_002', 'デザイナーグループ', 'デザイン相談', 'usr_002');

-- user_group_memberships
INSERT INTO user_group_memberships (id, user_id, group_id, role)
VALUES
    ('ugm_001', 'usr_001', 'grp_001', 'owner'),   -- 太郎はエンジニアグループのオーナー
    ('ugm_002', 'usr_002', 'grp_001', 'member'),  -- 花子はエンジニアグループのメンバー
    ('ugm_003', 'usr_001', 'grp_002', 'member'),  -- 太郎はデザイナーグループのメンバー
    ('ugm_004', 'usr_002', 'grp_002', 'owner');   -- 花子はデザイナーグループのオーナー
```

#### JOIN例
```sql
-- ユーザーが所属するグループ一覧
SELECT
    u.id AS user_id,
    u.email,
    g.id AS group_id,
    g.name AS group_name,
    ugm.role AS user_role_in_group,
    ugm.joined_at
FROM users u
INNER JOIN user_group_memberships ugm ON u.id = ugm.user_id
INNER JOIN groups g ON ugm.group_id = g.id
WHERE u.id = 'usr_001'
ORDER BY ugm.joined_at DESC;
```

#### グループメンバー一覧
```sql
-- グループに所属するユーザー一覧
SELECT
    g.id AS group_id,
    g.name AS group_name,
    u.id AS user_id,
    u.email,
    u.first_name,
    u.last_name,
    ugm.role,
    ugm.joined_at
FROM groups g
INNER JOIN user_group_memberships ugm ON g.id = ugm.group_id
INNER JOIN users u ON ugm.user_id = u.id
WHERE g.id = 'grp_001'
ORDER BY
    CASE ugm.role
        WHEN 'owner' THEN 1
        WHEN 'admin' THEN 2
        WHEN 'member' THEN 3
    END,
    ugm.joined_at;
```

---

## リレーション制約

### ON DELETE動作

| 親テーブル | 子テーブル | ON DELETE | 理由 |
|----------|----------|-----------|------|
| users | user_profiles | CASCADE | ユーザー削除時にプロフィールも削除 |
| users | user_sessions | CASCADE | ユーザー削除時にセッションも削除 |
| users | user_role_assignments | CASCADE | ユーザー削除時にロール割り当ても削除 |
| roles | user_role_assignments | CASCADE | ロール削除時に割り当ても削除 |
| users | user_group_memberships | CASCADE | ユーザー削除時にグループメンバーシップも削除 |
| groups | user_group_memberships | CASCADE | グループ削除時にメンバーシップも削除 |

### ON UPDATE動作

すべての外部キーで`ON UPDATE CASCADE`を設定
- 主キー変更時（通常は発生しない）に自動的に外部キーも更新

---

## パフォーマンス最適化

### インデックス戦略

#### 外部キーインデックス
```sql
-- 1対多リレーション
CREATE INDEX idx_user_sessions_user_id ON user_sessions(user_id);

-- 多対多リレーション（中間テーブル）
CREATE INDEX idx_user_role_assignments_user_id ON user_role_assignments(user_id);
CREATE INDEX idx_user_role_assignments_role_id ON user_role_assignments(role_id);
CREATE INDEX idx_user_group_memberships_user_id ON user_group_memberships(user_id);
CREATE INDEX idx_user_group_memberships_group_id ON user_group_memberships(group_id);
```

#### 複合インデックス
```sql
-- ユーザー+有効期限でのフィルタリングが頻繁な場合
CREATE INDEX idx_user_sessions_user_active
    ON user_sessions(user_id, is_active, expires_at);

-- ユーザー+ロールでの検索が頻繁な場合
CREATE INDEX idx_ura_user_role
    ON user_role_assignments(user_id, role_id);
```

---

## 変更履歴

| バージョン | 日付 | 変更者 | 変更内容 |
|------------|------|--------|----------|
| 1.0 | 2025-11-15 | 設計チーム | 初版作成 |
